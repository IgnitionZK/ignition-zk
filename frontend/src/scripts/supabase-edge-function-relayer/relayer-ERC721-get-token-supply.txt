import { serve } from "https://deno.land/std@0.177.0/http/server.ts";
import { ethers } from "https://esm.sh/ethers@6.11.1";
import { verify } from "https://deno.land/x/djwt@v2.7/mod.ts";

// CORS headers configuration
const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
  'Access-Control-Allow-Methods': 'POST, OPTIONS' // Allowed methods
};

// ERC721 ABI for totalSupply function
const ERC721_ABI = [
  "function totalSupply() view returns (uint256)",
  "function name() view returns (string)",
  "function symbol() view returns (string)",
];

// Declare these variables globally to avoid re-initializing them on every request.
let provider;
let jwtCryptoKey; // Declare jwtCryptoKey to hold the CryptoKey for JWT verification

// Initialize Ethers provider and JWT verification key.
// This block runs once when the Edge Function is loaded.
try {
  const rpcUrl = Deno.env.get("SEPOLIA_RPC_URL");
  const jwtSecretString = Deno.env.get("SUPA_JWT_SECRET"); // Get JWT secret as a string
  
  // Ensure environment variables are set.
  if (!rpcUrl) {
    throw new Error("SEPOLIA_RPC_URL environment variable is not set. Please configure it in Supabase secrets.");
  }
  if (!jwtSecretString) {
    throw new Error("SUPA_JWT_SECRET environment variable is not set. Please configure it in Supabase secrets.");
  }
  
  // Use Web Crypto API's subtle.importKey directly to create the CryptoKey
  jwtCryptoKey = await crypto.subtle.importKey("raw", new TextEncoder().encode(jwtSecretString), {
    name: "HMAC",
    hash: "SHA-256"
  }, true, [
    "verify"
  ] // usages: only for verification
  );
  
  // Create a JSON RPC provider using the provided RPC URL.
  provider = new ethers.JsonRpcProvider(rpcUrl);
  
  console.log("Ethers provider and JWT key initialized successfully.");
} catch (error) {
  console.error("Failed to initialize Ethers or JWT key:", error.message);
}

// Main handler for the Supabase Edge Function.
serve(async (req) => {
  // Handle CORS preflight requests (OPTIONS method)
  if (req.method === 'OPTIONS') {
    return new Response('ok', {
      headers: corsHeaders // Return success with CORS headers
    });
  }
  
  // Check if Ethers components were successfully initialized.
  if (!provider || !jwtCryptoKey) {
    return new Response(JSON.stringify({
      error: "Edge function initialization failed. Check server logs and environment variables."
    }), {
      status: 500,
      headers: {
        ...corsHeaders,
        "Content-Type": "application/json"
      }
    });
  }
  
  // Only allow POST requests for the actual logic.
  if (req.method !== "POST") {
    return new Response(JSON.stringify({
      error: "Method Not Allowed. Only POST requests are accepted."
    }), {
      status: 405,
      headers: {
        ...corsHeaders,
        "Content-Type": "application/json"
      }
    });
  }
  
  try {
    // Enforce JWT verification
    const authHeader = req.headers.get("Authorization");
    if (!authHeader) {
      return new Response(JSON.stringify({
        error: "Authorization header missing."
      }), {
        status: 401,
        headers: {
          ...corsHeaders,
          "Content-Type": "application/json"
        }
      });
    }
    
    const jwt = authHeader.split("Bearer ")[1];
    if (!jwt) {
      return new Response(JSON.stringify({
        error: "Bearer token missing from Authorization header."
      }), {
        status: 401,
        headers: {
          ...corsHeaders,
          "Content-Type": "application/json"
        }
      });
    }
    
    let userId;
    try {
      // Use the pre-created jwtCryptoKey for verification
      const payload = await verify(jwt, jwtCryptoKey, "HS256");
      if (typeof payload.sub !== "string") {
        throw new Error("Invalid JWT payload: 'sub' (user ID) is not a string.");
      }
      userId = payload.sub; // Extract user ID from the payload
      console.log(`JWT verified for user: ${userId}`);
    } catch (e) {
      console.error("JWT verification failed:", e.message);
      return new Response(JSON.stringify({
        error: `Unauthorized: Invalid JWT. ${e.message}`
      }), {
        status: 401,
        headers: {
          ...corsHeaders,
          "Content-Type": "application/json"
        }
      });
    }
    
    // Parse the request body to get contract address and group ID.
    const { contractAddress, groupId } = await req.json();
    
    // Validate required parameters.
    if (!contractAddress || !groupId) {
      return new Response(JSON.stringify({
        error: "Missing required parameters: 'contractAddress' and 'groupId' in request body."
      }), {
        status: 400,
        headers: {
          ...corsHeaders,
          "Content-Type": "application/json"
        }
      });
    }
    
    // Validate contract address format
    if (!ethers.isAddress(contractAddress)) {
      return new Response(JSON.stringify({
        error: "Invalid contract address format."
      }), {
        status: 400,
        headers: {
          ...corsHeaders,
          "Content-Type": "application/json"
        }
      });
    }
    
    console.log(`Received request to get token supply for user ${userId}:`);
    console.log(`  Contract Address: ${contractAddress}`);
    console.log(`  Group ID: ${groupId}`);
    
    // Create contract instance
    const contract = new ethers.Contract(contractAddress, ERC721_ABI, provider);
    
    // Check if contract exists on the network
    const code = await provider.getCode(contractAddress);
    if (code === "0x") {
      return new Response(JSON.stringify({
        error: `Contract at address ${contractAddress} does not exist on the network.`
      }), {
        status: 400,
        headers: {
          ...corsHeaders,
          "Content-Type": "application/json"
        }
      });
    }
    
    // Get contract info
    let contractName, contractSymbol;
    try {
      contractName = await contract.name();
      contractSymbol = await contract.symbol();
      console.log(`Contract info - Name: ${contractName}, Symbol: ${contractSymbol}`);
    } catch (nameError) {
      console.warn(`Could not get contract name/symbol: ${nameError.message}`);
      contractName = "Unknown";
      contractSymbol = "Unknown";
    }
    
    // Get total supply
    let totalSupply;
    try {
      totalSupply = await contract.totalSupply();
      console.log(`Total supply from contract: ${totalSupply}`);
    } catch (supplyError) {
      // Handle cases where no tokens have been minted or contract is not properly initialized
      if (
        supplyError.message.includes("could not decode result data") ||
        supplyError.message.includes("BAD_DATA") ||
        supplyError.message.includes('value="0x"')
      ) {
        console.log("Contract has no tokens minted or is not properly initialized, returning 0");
        totalSupply = 0;
      } else {
        throw supplyError;
      }
    }
    
    // Convert to number and handle edge cases
    const totalSupplyNumber = totalSupply === undefined || totalSupply === null ? 0 : Number(totalSupply);
    
    console.log(`Successfully retrieved token supply: ${totalSupplyNumber}`);
    
    // Return a success response with token supply details.
    return new Response(JSON.stringify({
      message: "Token supply retrieved successfully.",
      totalSupply: totalSupplyNumber,
      contractAddress: contractAddress,
      contractName: contractName,
      contractSymbol: contractSymbol,
      groupId: groupId
    }), {
      status: 200,
      headers: {
        ...corsHeaders,
        "Content-Type": "application/json"
      }
    });
    
  } catch (error) {
    // Catch any errors during the process and return an error response.
    console.error("Error in relayer-ERC721-get-token-supply Edge Function:", error);
    return new Response(JSON.stringify({
      error: error.message || "An unknown internal server error occurred.",
      stack: error.stack // Include stack trace for debugging
    }), {
      status: 500,
      headers: {
        ...corsHeaders,
        "Content-Type": "application/json"
      }
    });
  }
}); 