import { serve } from "https://deno.land/std@0.177.0/http/server.ts";
import { ethers } from "https://esm.sh/ethers@6.11.1";
import { verify } from "https://deno.land/x/djwt@v2.7/mod.ts";
// CORS headers configuration
const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
  'Access-Control-Allow-Methods': 'POST, OPTIONS' // Allowed methods
};
// GovernanceManager Proxy address. This is the address of your deployed proxy contract.
const GOVERNANCE_MANAGER_PROXY_ADDRESS = Deno.env.get("GOVERNOR_CONTRACT_ADDRESS");
// ABI for the delegateInitRoot and delegateSetRoot functions.
const GOVERNANCE_MANAGER_ABI = [
  "function delegateSetRoot(bytes32 newRoot, bytes32 groupKey) external",
  "function getMembershipManager() external view returns (address)",
  "function owner() external view returns (address)",
  "function delegateGetNftImplementation() external view returns (address)",
  "function delegateSetMemberCount(bytes32 groupKey, uint256 memberCount) external"
];
// Declare these variables globally to avoid re-initializing them on every request.
let provider;
let wallet;
let contract;
let jwtCryptoKey; // Declare jwtCryptoKey to hold the CryptoKey for JWT verification
// Initialize Ethers provider, wallet, and contract instance.
// This block runs once when the Edge Function is loaded.
try {
  const rpcUrl = Deno.env.get("SEPOLIA_RPC_URL");
  const privateKey = Deno.env.get("RELAYER_PRIVATE_KEY");
  const jwtSecretString = Deno.env.get("SUPA_JWT_SECRET"); // Get JWT secret as a string
  // Ensure environment variables are set.
  if (!rpcUrl) {
    throw new Error("SEPOLIA_RPC_URL environment variable is not set. Please configure it in Supabase secrets.");
  }
  if (!privateKey) {
    throw new Error("RELAYER_PRIVATE_KEY environment variable is not set. Please configure it in Supabase secrets.");
  }
  if (!jwtSecretString) {
    throw new Error("SUPA_JWT_SECRET environment variable is not set. Please configure it in Supabase secrets.");
  }
  // Use Web Crypto API's subtle.importKey directly to create the CryptoKey
  jwtCryptoKey = await crypto.subtle.importKey("raw", new TextEncoder().encode(jwtSecretString), {
    name: "HMAC",
    hash: "SHA-256"
  }, true, [
    "verify"
  ] // usages: only for verification
  );
  // Create a JSON RPC provider using the provided RPC URL.
  provider = new ethers.JsonRpcProvider(rpcUrl);
  // Create a wallet instance from the relayer's private key, connected to the provider.
  wallet = new ethers.Wallet(privateKey, provider);
  // Create a contract instance, connected to the wallet for signing transactions.
  contract = new ethers.Contract(GOVERNANCE_MANAGER_PROXY_ADDRESS, GOVERNANCE_MANAGER_ABI, wallet);
  console.log("Ethers provider, wallet, and contract initialized successfully.");
} catch (error) {
  console.error("Failed to initialize Ethers or JWT key:", error.message);
}
// Main handler for the Supabase Edge Function.
serve(async (req)=>{
  // Handle CORS preflight requests (OPTIONS method)
  if (req.method === 'OPTIONS') {
    return new Response('ok', {
      headers: corsHeaders // Return success with CORS headers
    });
  }
  // Check if Ethers components were successfully initialized.
  if (!provider || !wallet || !contract || !jwtCryptoKey) {
    return new Response(JSON.stringify({
      error: "Edge function initialization failed. Check server logs and environment variables."
    }), {
      status: 500,
      headers: {
        ...corsHeaders,
        "Content-Type": "application/json"
      }
    });
  }
  // Only allow POST requests for the actual logic.
  if (req.method !== "POST") {
    return new Response(JSON.stringify({
      error: "Method Not Allowed. Only POST requests are accepted."
    }), {
      status: 405,
      headers: {
        ...corsHeaders,
        "Content-Type": "application/json"
      }
    });
  }
  try {
    // Enforce JWT verification
    const authHeader = req.headers.get("Authorization");
    if (!authHeader) {
      return new Response(JSON.stringify({
        error: "Authorization header missing."
      }), {
        status: 401,
        headers: {
          ...corsHeaders,
          "Content-Type": "application/json"
        }
      });
    }
    const jwt = authHeader.split("Bearer ")[1];
    if (!jwt) {
      return new Response(JSON.stringify({
        error: "Bearer token missing from Authorization header."
      }), {
        status: 401,
        headers: {
          ...corsHeaders,
          "Content-Type": "application/json"
        }
      });
    }
    let userId;
    try {
      // Use the pre-created jwtCryptoKey for verification
      const payload = await verify(jwt, jwtCryptoKey, "HS256");
      if (typeof payload.sub !== "string") {
        throw new Error("Invalid JWT payload: 'sub' (user ID) is not a string.");
      }
      userId = payload.sub; // Extract user ID from the payload
      console.log(`JWT verified for user: ${userId}`);
    } catch (e) {
      console.error("JWT verification failed:", e.message);
      return new Response(JSON.stringify({
        error: `Unauthorized: Invalid JWT. ${e.message}`
      }), {
        status: 401,
        headers: {
          ...corsHeaders,
          "Content-Type": "application/json"
        }
      });
    }
    // Parse the request body to get tree_version, root_value, and group_key.
    const { tree_version, root_value, group_key, member_count } = await req.json();
    // Validate required parameters.
    if (typeof tree_version === 'undefined' || !root_value || !group_key || !member_count) {
      return new Response(JSON.stringify({
        error: "Missing required parameters: 'tree_version', 'root_value', 'group_key' or 'member_count' in request body."
      }), {
        status: 400,
        headers: {
          ...corsHeaders,
          "Content-Type": "application/json"
        }
      });
    }
    // Convert string inputs to bytes32 format.
    let bytes32Root;
    if (root_value.startsWith("0x") && root_value.length === 66) {
      // Already a hex string, use it directly
      bytes32Root = root_value;
    } else {
      // Convert decimal string to bytes32 by converting to BigInt, then to hex, then zero-padding
      bytes32Root = ethers.zeroPadValue(ethers.toBeHex(BigInt(root_value)), 32);
    }
    const bytes32GroupKey = group_key;
    const memberCount = parseInt(member_count);
    console.log(`Member count: ${memberCount}, type: ${typeof memberCount}`);
    console.log(`Received request to update root for user ${userId}:`);
    console.log(`  Tree Version: ${tree_version}`);
    console.log(`  Original Root Value: '${root_value}'`);
    console.log(`  Converted Root (bytes32): '${bytes32Root}'`);
    console.log(`  Converted Group Key (bytes32 with modulo reduction): '${bytes32GroupKey}'`);
    //const mmAddress = await contract.getMembershipManager();
    //console.log("MM address: ", mmAddress);
    //const ownerAddress = await contract.owner();
    //console.log("GM owner:", ownerAddress);
    //const nftImp = await contract.delegateGetNftImplementation();
    //console.log("NFT implementation address in MM: ", nftImp);
    let transactionResponse;
    let actionPerformed;
    //if (tree_version === 1) {
    // Call delegateInitRoot for the first version of the tree
    //  console.log("Calling delegateInitRoot...");
    //  transactionResponse = await contract.delegateInitRoot(bytes32Root, bytes32GroupKey);
    //  actionPerformed = "delegateInitRoot";
    //} else {
    // Call delegateSetRoot for subsequent versions
    console.log("Calling delegateSetRoot...");
    transactionResponse = await contract.delegateSetRoot(bytes32Root, bytes32GroupKey);
    actionPerformed = "delegateSetRoot";
    //}
    console.log(`Transaction sent. Transaction Hash: ${transactionResponse.hash}`);
    const receipt = await transactionResponse.wait();
    if (!receipt) {
      throw new Error("Transaction receipt not found. The transaction might not have been mined successfully or timed out.");
    }
    console.log(`Transaction for root update successfully mined. Block Number: ${receipt.blockNumber}, Gas Used: ${receipt.gasUsed}`);
    //call setMembersCount after the initRoot / setRoot transactions have been successfully mined:
    let followUpTransactionResponse;
    let followUpActionPerformed;
    console.log("Calling delegateSetMemberCount...");
    followUpTransactionResponse = await contract.delegateSetMemberCount(bytes32GroupKey, memberCount);
    followUpActionPerformed = "delegateSetMemberCount";
    console.log(`Transaction for setting member count sent. Transaction Hash: ${followUpTransactionResponse.hash}`);
    const receiptFollowUp = await followUpTransactionResponse.wait();
    if (!receiptFollowUp) {
      throw new Error("Transaction receipt for setting member count not found. The transaction might not have been mined successfully or timed out.");
    }
    console.log(`Follow-up transaction for setting the member count successfully mined. Block Number: ${receiptFollowUp.blockNumber}, Gas Used: ${receiptFollowUp.gasUsed}, memberCount: ${memberCount}`);
    // Return a success response with transaction details.
    return new Response(JSON.stringify({
      message: `Merkle root updated successfully via ${actionPerformed}.`,
      transactionHash: transactionResponse.hash,
      actionPerformed: actionPerformed,
      blockNumber: receipt.blockNumber.toString(),
      gasUsed: receipt.gasUsed.toString()
    }), {
      status: 200,
      headers: {
        ...corsHeaders,
        "Content-Type": "application/json"
      }
    });
  } catch (error) {
    // Catch any errors during the process and return an error response.
    console.error("Error in relayer-update-root Edge Function:", error);
    return new Response(JSON.stringify({
      error: error.message || "An unknown internal server error occurred.",
      stack: error.stack // Include stack trace for debugging
    }), {
      status: 500,
      headers: {
        ...corsHeaders,
        "Content-Type": "application/json"
      }
    });
  }
});
