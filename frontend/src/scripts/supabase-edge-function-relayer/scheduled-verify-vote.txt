import { serve } from "https://deno.land/std@0.177.0/http/server.ts";
import { ethers } from "https://esm.sh/ethers@6.11.1";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2.42.0";

// ================================================================
// Environment Variables & Initialization
// This block runs once when the Edge Function is loaded.
// ================================================================

// GovernanceManager Proxy address.
const GOVERNOR_CONTRACT_ADDRESS = Deno.env.get("GOVERNOR_CONTRACT_ADDRESS");
// ABI for the delegateVerifyVote function on GovernanceManager.
const GOVERNANCE_MANAGER_ABI = [
  "function delegateVerifyVote(uint256[24] calldata proof, uint256[5] calldata publicSignals, bytes32 groupKey, bytes32 contextKey)"
];

// Supabase details for database interaction
const SUPABASE_URL = Deno.env.get("SUPABASE_URL");
const SUPABASE_SERVICE_ROLE_KEY = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY");

// Ethers details for blockchain interaction
const RPC_URL = Deno.env.get("SEPOLIA_RPC_URL");
const RELAYER_PRIVATE_KEY = Deno.env.get("RELAYER_PRIVATE_KEY");

// The API_KEY_SECRET is no longer needed since this function will be called by
// the internal Supabase cron job, not an external service.
// const API_KEY_SECRET = Deno.env.get("API_KEY_SECRET");

let supabaseClient;
let provider;
let wallet;
let contract;

try {
  // Ensure all necessary environment variables are set.
  if (!SUPABASE_URL || !SUPABASE_SERVICE_ROLE_KEY || !RPC_URL || !GOVERNOR_CONTRACT_ADDRESS || !RELAYER_PRIVATE_KEY) {
    throw new Error("Missing one or more required environment variables.");
  }

  // Create a Supabase client with the service role key to bypass RLS.
  supabaseClient = createClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY);

  // Create an Ethers provider and wallet instance for the relayer.
  provider = new ethers.JsonRpcProvider(RPC_URL);
  wallet = new ethers.Wallet(RELAYER_PRIVATE_KEY, provider);

  // Create a contract instance connected to the relayer's wallet.
  contract = new ethers.Contract(GOVERNOR_CONTRACT_ADDRESS, GOVERNANCE_MANAGER_ABI, wallet);

  console.log("Initialization successful.");
} catch (error) {
  console.error("Initialization failed:", error.message);
  // Re-throw the error to prevent the function from running with a broken state.
  throw error;
}

// ================================================================
// Main Edge Function Handler
// ================================================================

serve(async (req) => {
  // The API_KEY_SECRET check is no longer needed because this function is
  // intended to be called by a secure, internal Supabase cron job.
  // const authHeader = req.headers.get("Authorization");
  // if (!authHeader || authHeader.replace("Bearer ", "") !== API_KEY_SECRET) {
  //     return new Response(JSON.stringify({ error: "Unauthorized access." }), {
  //         status: 401,
  //         headers: { "Content-Type": "application/json" }
  //     });
  // }

  try {
    console.log("Scheduled job started. Fetching active epochs...");

    // 1. Fetch only epochs that are not yet archived.
    // The `review_start` column is used to check if the voting phase has ended.
    const { data: epochs, error: epochsError } = await supabaseClient
      .from("ignitionzk.epochs")
      .select("epoch_id, review_start")
      .eq("is_archived", false);

    if (epochsError) {
      console.error("Error fetching epochs:", epochsError);
      throw new Error(epochsError.message);
    }
    
    const currentTime = new Date().toISOString();
    console.log(`Current time is: ${currentTime}`);

    // 2. Iterate through each active epoch to check if the voting phase has ended.
    for (const epoch of epochs) {
      console.log(`Processing epoch ID: ${epoch.epoch_id}`);

      const votingPhaseEnd = epoch.review_start;
      console.log(`Voting phase for epoch ${epoch.epoch_id} ends at: ${votingPhaseEnd}`);
      
      // The condition is that the voting phase must have ended.
      if (currentTime > votingPhaseEnd) {
        console.log(`Voting phase for epoch ${epoch.epoch_id} has ended. Fetching unverified proofs...`);

        // 3. If the voting phase has ended, fetch all unverified voting proofs for this epoch.
        const { data: proofs, error: proofsError } = await supabaseClient
          .from("ignitionzk.proofs")
          .select("proof_id, proof, public_signals, group_id, context_key")
          .eq("epoch_id", epoch.epoch_id)
          .eq("circuit_id", "voting")
          .eq("is_verified", false);
        
        if (proofsError) {
          console.error("Error fetching proofs:", proofsError);
          throw new Error(proofsError.message);
        }

        console.log(`Found ${proofs.length} unverified proofs to process.`);

        // 4. Loop through each proof and send it to the blockchain for verification.
        for (const proofData of proofs) {
          try {
            console.log(`Verifying proof with ID: ${proofData.proof_id}`);
            
            // Re-construct proof and public signals from database strings/arrays
            const proof = proofData.proof.map(BigInt);
            const publicSignals = proofData.public_signals.map(BigInt);
            const groupKey = proofData.group_id; // Using group_id from proofs table
            const contextKey = proofData.context_key; // Using context_key from proofs table

            // Call the delegateVerifyVote function on the GovernanceManager contract.
            const transactionResponse = await contract.delegateVerifyVote(
              proof,
              publicSignals,
              groupKey,
              contextKey
            );

            console.log(`Transaction submitted. Hash: ${transactionResponse.hash}`);
            
            // Wait for the transaction to be mined.
            const receipt = await transactionResponse.wait();
            console.log(`Transaction confirmed in block ${receipt.blockNumber}`);

            // 5. Update the proof's status in the database.
            const { error: updateError } = await supabaseClient
              .from("ignitionzk.proofs")
              .update({ is_verified: true })
              .eq("proof_id", proofData.proof_id);

            if (updateError) {
              console.error(`Error updating proof ${proofData.proof_id}:`, updateError);
            } else {
              console.log(`Proof ${proofData.proof_id} successfully verified and updated in database.`);
            }

          } catch (verifyError) {
            console.error(`Failed to verify proof ${proofData.proof_id}:`, verifyError);
            // Log the error but continue to the next proof.
          }
        }
      }
    }

    console.log("Scheduled job completed successfully.");
    return new Response(JSON.stringify({ message: "Verification check completed." }), {
      status: 200,
      headers: { "Content-Type": "application/json" }
    });

  } catch (error) {
    console.error("Error in scheduled job:", error);
    return new Response(JSON.stringify({ error: error.message || "An unknown error occurred." }), {
      status: 500,
      headers: { "Content-Type": "application/json" }
    });
  }
});
