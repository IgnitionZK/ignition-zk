CREATE OR REPLACE FUNCTION atomic_commitment_insertion(
  p_group_id UUID,
  p_group_member_id UUID,
  p_commitment_value TEXT
) RETURNS JSON AS $$
DECLARE
  v_new_commitment_record RECORD;
  v_commitment_count INTEGER;
BEGIN
  -- Set reasonable timeouts
  SET lock_timeout = '30s';
  SET statement_timeout = '60s';
  
  BEGIN
    -- Step 1: Lock the table and count active commitments (separate operations)
    SELECT COUNT(*)
    INTO v_commitment_count
    FROM ignitionzk.merkle_tree_leaves
    WHERE group_id = p_group_id AND is_active = true;
    
    -- Lock the table to prevent concurrent modifications
    PERFORM 1 FROM ignitionzk.merkle_tree_leaves 
    WHERE group_id = p_group_id 
    LIMIT 1 
    FOR UPDATE;
    
    -- Step 2: Insert the new commitment
    INSERT INTO ignitionzk.merkle_tree_leaves (
      group_member_id,
      commitment_value,
      group_id,
      is_active,
      created_at
    ) VALUES (
      p_group_member_id,
      p_commitment_value,
      p_group_id,
      true,
      NOW()
    ) RETURNING * INTO v_new_commitment_record;
    
    RETURN json_build_object(
      'success', true,
      'member_count', v_commitment_count + 1,
      'commitment_id', v_new_commitment_record.commitment_id
    );
    
  EXCEPTION
    WHEN lock_not_available THEN
      RAISE EXCEPTION 'System is busy, please try again in a moment';
    WHEN OTHERS THEN
      RAISE EXCEPTION 'Commitment insertion failed: %', SQLERRM;
  END;
END;
$$ LANGUAGE plpgsql;